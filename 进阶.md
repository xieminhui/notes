### 1.http状态码详解  
> 304：这个请求跟缓存有关，当客户端缓存了服务器的资源，但是它又不知道是不是最新时，他就会发一个请求给
服务器，请求头带有`If-Modified-Since`,其值是服务器上次放回的`Last-Modified`响应的日期值，还会提供一个`If-None-Match`
的请求头，其值为服务器上次放回的`ETag`响应值。  
![](image/304.jpg)  

服务器接到这个请求，并读取这两个值，如果服务器资源跟客户端请求资源一致，即没有发生改变，则服务器放回
304，`http/304 Not Modified`，客户端继续读缓存资源。如果客户端缓存资源过期，则服务器放回`http/200`，响应体是
最新内容。<strong>只有客户端缓存了资源并且请求头包含上述两个参数时，才能发送改请求，否则表示无条件请求该资源
，服务器也无条件放回完整最新资源。</strong>   
### 2.domain设置规则：  
```
域名A: http://a.xxx.com  域名B: http://c.xxx.com
```
为了a b两个页面的可以相互通信，必须设置domian相同。有两个注意点：  
1. 只能往小设置，比如域名a可以设置为`xxx.com`,不能设置为`a.yyy.com`,即只能是域名a包含的域名。
2. 松散的域名设置为紧绷后，不能往回设置了。`xxx.com`设置完成后不能设置为`a.xxx.com`。

### 3.输出一个页面所有用到的标签  
```
var arr =[];
function a(obj){

	if(arr.indexOf(obj.nodeName) == -1)arr.push(obj.nodeName);
	if(obj.children){
    	for(var i=0;i<obj.children.length;i++){
        	a(obj.children[i]);
		}
	}
}
a(document);
```
```
var b = ['#document'];//doucment先push
var list = document.getElementsByTagName('*');
Array.prototype.forEach.call(list,function(item){
	if(b.indexOf(item.nodeName) == -1)b.push(item.nodeName)
})

ie8以下没有element.children这个属性，下面是兼容children写法,
// Overwrites native 'children' prototype.
// Adds Document & DocumentFragment support for IE9 & Safari.
// Returns array instead of HTMLCollection.
(function(constructor) {
    if (constructor &&
        constructor.prototype &&
        constructor.prototype.children == null) {
        Object.defineProperty(constructor.prototype, 'children', {
            get: function() {
                var i = 0, node, nodes = this.childNodes, children = [];
                while (node = nodes[i++]) {
                    if (node.nodeType === 1) {
                        children.push(node);
                    }
                }
                return children;
            }
        });
    }
})(window.Node || window.Element);

```  

### 4.跨域解决方案：  
1. 设置domain，详见第2点。<strong>特别注意，这个跨域成立的前提是
主域相同</srtong>  
2. 完全不同源的跨域，即两个不同页面之间的通信。  
2.1 通过window.name跨域：  
`window.name`有个特性，就是在一个窗口的生命周期内（关闭之前），这个窗口内所有载入的页面都是共享一个
`window.name`的，即使这个窗口加载不同源的页面，他们也是共享`window.name`。所以不同页面之间可以这样
通信：
    ```
    //a.html
    //首先父b自己建一个iframe，这个iframe的src指向不同的页面b
    let iframe = document.createElement('iframe'); 
    iframe .src = b;
    
    .......
    //b.html要做的事，将数据写到window.name
    window.name = data;
    
    .......
    //a.html接着要做的事，将ifram.src改回自己主域下的路径,取出数据
    iframe.src = a//xxx.html;
    let data = document.getElementById('myFrame').contentWindow.name;
    ```
    2.2 window.hash跨域：  
    原理：父窗口可以修改自己下面的iframe的URL，iframe也可以修改父的URL,URL有一部分叫做hash值。就是一个
    URL带#后面的值。修改它不会产生http请求，但是会产生浏览器记录。  
  
    假如父`baidu.com/a.html` ,iframe里面是`google.com/b.html`。  
    >a跟b通信  
      
    - a修改iframe的src为`google.com/b.html#lalaxiaojie`.  
    - b监听到url发生变化，获取数据.  
    >b跟a通信，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，
    所以要借助于父窗口域名下的一个代理iframe。  
    
    -  b自己建一个iframe,iframe的src是`baidu.com/proxy.html`,并写上数据`baidu.com/proxy.html#
    pipigege`.  
    - proxy.html监听自己的url发生变化，修改a.html的url`baidu.com/a.html#pipigege` , a跟proxy是同域的.  
    - a监听自己的url，获取数据.  

    2.3 通过window.postMessage跨域,这个是html5的全新api，不做详解，要用去搜api。
    ![](image/postMessage.png)

3. JSONP。script不受同源策略限制，同时跨域请求到的脚本不仅包含数据，还可以有一个回调。  
```
    //http://baidu.com/a是要请求的脚本
    let data = {
        lala: 'hellow'
    };
    callback(data);
    
    ..................................
    //http://google.com/b获取a的数据
    let callback = function(){
       ...
    }
    let script = document.createElement('script');
    script.src = 'http//baidu.com/a';
    document.body.append(script);
```
jquery的ajax有jsonp这个调用方式，在参数dataType中设置jsonp,jsonpCallback设置你的回调。  

4. 跨域资源共享CORS（html5）。服务器设置`Access-Control-Allow-OriginHTTP`
响应头之后，浏览器将会允许跨域请求。

```
//服务器设置
access-control-allow-origin: https://baidu.com //允许百度来访问我
access-control-allow-origin: * //任何人都可以
```
5. 此外还有长连接like comet和websocket这些方案。

### 5.跨域后可以访问的window方法.
![](image/跨域的window.png)

### 6.网站安全
1. xss攻击：跨站脚本攻击  
1.1 原理：web没有对用户提交的请求进行充分的检查和过滤，导致一些恶意攻击者
可以在提交的数据中加入HTML代码（像< ,>)，并且将未转义的字符输出的第三方用户浏览器中
运行。
1.2 举个简单例子：比如在一个评论社区网站，没有预防xss攻击，这时候有个恶意用户a提交了一条评论
    ```
    <script>
    let cookie = document.cookie;//好了，他已经够拿到某个用户页面的cookie
    send(cookie)//发到网站hack
    </script>
    
    ```
    这个时候用户b登录了系统，查看了这个页面的评论。那么这个用户的cookie在不知觉的
    情况下就被人拿了。  
    1.3预防措施：  
    + 过滤特殊的字符串
    + 使用http头指定类型
    ```
    w.Header().Set("Content-Type","text/javascript")
            
    这样就可以让浏览器解析javascript代码，而不会是html输出。
     ```  
     参考链接：https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.3.md
     https://blog.csdn.net/u011781521/article/details/53894399
     
### 7.网站加密
1.md5加密：使用一个哈希算法加密原本的明文，得到加密后的明文。
+ md5不能算是加密算法，因为它是单向的、不可逆的，你没法对经过md5运算过的密码进行“解密”而得到原始的明文密码，
但确实在md5与密码发生关系时我们喜欢叫它“加密”。所以就算攻击者知道你用了
md5哈希算法，截获了你“加密”后的密码，即md5(password)（不妨设md5哈希函数为md5()，
用户明文密码为password），也无法通过倒推得知用户的明文密码，只能暴力穷举猜测用户的密码。                              
其次，就算攻击者不知道password，只知道md5(password)，也足够了，
他只要向服务器发送md5(password)便能通过认证。而且验证的过程仍为明文对比，
只是从对比明文密码变成对比明文密码的哈希值。为了解决这个问题，有人提出给密码“加盐”：
服务器既不存储明文密码password，也不存储md5(password)，而是存储
md5(password)和salt，这个salt即“盐”。用户每次登陆时，服务器先生成一个
动态的、短时间内不会重复的salt发送给用户，然后用户将md5(md5(password) + salt)
发回给服务器，服务器经过同样的运算后对比结果，一致则通过验证。这样一来，
攻击者就算截获了salt和md5(md5(password) + salt)，也无法倒推出md5(password)，
同时salt一经使用，就会失效，攻击者就无法通过重新发送
md5(md5(password) + salt)来伪装成用户。
但上述做法有个问题（至少一个问题）：设置密码时，用户必须告知服务器
md5(password)，同时服务器上会明文存储md5(password)，如果设置密码时
md5(password)被截获，或服务器的数据库被入侵，攻击者就会得知md5(password)，
从而就可以伪装成用户通过密码验证了。而且，如果这个用户在其它网站也使用了
一样的密码（这是很常见的），其它网站又刚好使用了一样的密码验证方式，
攻击者就能同时获得该用户在多个网站的授权（撞库）。
这个问题的根本原因是设计者没有摆脱“明文密码”，
用md5(password)来代替明文密码与直接使用明文密码没有太大区别，因此有人提出，
我们不要用md5(password)，改用md5(password + salt)吧。这里的salt不是
前面的salt，前面的是“动态盐”，现在所说的是“静态盐”，为了区分，用dsalt代
表动态盐，用ssalt代表静态盐。那么登陆方式就变成：服务器存储
md5(password + ssalt)和与之配套的静态盐ssalt（静态盐在设置密码时配套生成），
登陆时，服务器动态生成随机的动态盐dsalt，将ssalt和dsalt一同发给用户，
用户将md5(md5(password + ssalt) + dsalt)发回给服务器，
服务器进行同样的运算，结果一致则验证通过。这样一来，就算攻击者知道了
md5(password + ssalt)，也只是攻破了这个用户在一个网站上的账户，而不能
攻破该用户使用的其它网站的账户——因为攻击者不能通过md5(password + ssalt)
倒推出md5(password)，且对于其它网站，静态盐ssalt也是不同的.

2.对称加密
>双方加密和解密使用相同的密钥。这个密钥用于通信双方队明文进行加密和解密，原理就是
mod运算。

3.非对称加密
>对称加密中就有公钥和私钥之分。公钥是可以公开的，即所有人都可以知道，但是私钥是你自己
保留的，用于解密使用。客户端A跟服务器端B通信，A用公钥加密后的数据只有知道私钥的
服务器B才能解开，B发送给A的数据呢，所有人都可以用公钥解开。
+ 简单的这种非对称加密会遭遇中间人攻击，可以用数字证书预防。https://blog.ymfe.org/Man-In-The-Middle-Attack/

+ <strong>现在的通信都是先用非对称加密进行通信，交换用于对称加密生成密钥的因子
，然后用双方生成的这个因子生成对称加密的密钥，接着用这个密钥进行安全通信。</strong>

### 8.网站优化问题
> 先来普及下知识，浏览器跟服务器通信发请求的时候是有连接数限制的，看个表。

|ersion|HTTP 1.0 server (broadband connection)	|HTTP 1.1 server (broadband connection)|HTTP 1.0 server (dial-up connection)|HTTP 1.1 server (dial-up connection)|
|:-----|:-------|:-----|:-----|:-----|
|Internet Explorer 7 and earlier   |4      |2  |4 |2|
|Internet Explorer 8               |6      |6  |4 |2|

在谷歌下，最大连接数是6.当然IE的限制可以在注册表中修改，
HKEY_LOCAL_MACHINE\SOFTWARE\   Microsoft\Internet Explorer\MAIN\FeatureControl\FEATURE_MAXCONNECTIONSPERSERVER。
谷歌下，超过连接数就会被阻塞，排队，
![](image/stalled.png)
因为前面有迭代请求的关系，连接数超过6个，而且响应又慢，导致一个静态的html文件被阻塞了
5秒多。

1. 所以对js,css这些静态资源进行压缩合并，可以减少请求数。
减少请求数量 也就是降低瀑布图的高度. 瀑布图越矮越好.
2. 图片雪碧图。
3. 请求接口优化，对于相同接口同时多次请求数据的，合并成一个批量接口，一起放回
初始化数据。

### 9. [cookie详解](https://segmentfault.com/a/1190000004556040)
### 10.javascript内存牵扯的东西
> js就两种值，引用或基本类型值。基本的数据类型五种：`undefined，null,
boolen,Number,String`，这五种是值来访问操作的，即可以直接操作内存中的那个值。

>函数传递是按值来传递的，参数是对象的时候即使是按值传递，它也是按引用来的。
````angular2html
var num = 20;
function add(count){
    count += 10;
    return count;
}
var result = add(num);
console.log(num);//20
console.log(result);//30

//----------------对于对象----------------------
function setName(obj){
    obj.name = 'Eason';
}
var person = new Object();
setName(person);
console.log(person.name);//eason

//****************************************
        说明对象参数按引用传递了
//*******************************

//列子2
function setName(obj){
    obj.name = 'Eason';
    obj = new Object();
    obj.name = ’chenlaoshi';
}
var person = new Object();
setName(person);
console.log(person.name);//eason

why?!!!!!!!!!!!!!!!!!
````
我们解释下例子2为什么是这样，看图
![](image/对象参数传递.png)
其实上述代码就是下面这样
```
function setName(){
    var obj = person;
    obj.name = 'Eason';
    obj = new Object();
    obj.name = ’chenlaoshi';
}
var person = new Object();
setName(person);
console.log(person.name);//eason
```
> 执行环境跟作用域链。执行环境定义了变量和函数有权访问的数据，其实就是作用域每
个环境都有一个与之关联的变量对象，这个环境中所有定义的变量和函数都保存在
这变量对象中。当代码在一个环境中运行的时候，就会创建变量对象的一个作用域链。

> AO：Activetion Object（活动对象）
VO：Variable Object（变量对象）
VO对应的是函数创建阶段，JS解析引擎进行预解析时，
所有的变量和函数的声明，统称为Variable Object。该变量与执行上下文相关，
知道自己的数据存储在哪里，并且知道如何访问。VO是一个与执行上下文相关的特殊对象，
它存储着在上下文中声明的以下内容：
+ 变量 (var, 变量声明);
+ 函数声明 (FunctionDeclaration, 缩写为FD);
+ 函数的形参
```
function a(x,y){
    var b=x+y;
    function say(){
      console.log(b);
    }

}
//b, say, x, y组合的对象是vo,不过该对象基本都是undefined
```
AO对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，
该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是
Activetion Object。该对象包含了：
+ 函数的所有局部变量
+ 函数的所有命名参数
+ 函数的参数集合
+ 函数的this指向
```angular2html

a(4,5);
//  我用JS对象来表示AO
//  AO = {
//	    this : window,
//	    arguments : [4,5],
//	    x : 4,
//	    y : 5,
//	    say : ,
//	    b : undefined
//  }
```
当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）
来保证对执行环境有权访问的变量和函数的有序访问。作用域第一个对象始终是当前执行
代码所在环境的变量对象（VO）
```
function a(x,y){
	var sum = x + y;
	return sum;
}
```
假设函数是在全局作用域中创建的，在函数a创建的时候，它的作用域链填入全局对象,
全局对象中有所有全局变量，此时的全局变量就是VO。此时的作用域链就是：
```angular2html
此时作用域链（Scope Chain）只有一级,就为Global Object

	scope(add) -> Global Object(VO)
	
	VO = {
		this : window,
		add : 
	}
```
![](image/scope-chain1.png)
如果是函数执行阶段，那么将其activation object（AO）作为作用域链第一个对象
，第二个对象是上级函数的执行上下文AO，下一个对象依次类推。
```angular2html
 var tatal=a(5,10);
```
![](image/scope-chain2.png)

> 内存回收
+ 标记清除（mark and sweep）:当变量进入执行环境的时候(调用)，比如函数中声明一个变量，
垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为
“离开环境”。这时候就会回收变量所占用内存。
+ 引用计数：引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一
个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个
，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这
个值没法被访问了，因此可以将其占用的空间回收。

> 闭包带来的问题：造成变量不能被回收。ie9下只要涉及
com的都是使用引用计数的方式，闭包就会导致引用计数一直存在。
现在我感觉基本都不用担心这个东西了。

### 11.[XMLHttpRequest](https://segmentfault.com/a/1190000004322487)